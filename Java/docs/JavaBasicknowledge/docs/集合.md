<!-- TOC -->

- [集合](#集合)
  - [综述](#综述)
    - [方法](#方法)
    - [迭代器](#迭代器)
  - [`List`](#list)
    - [创建`List`](#创建list)
    - [遍历`List`](#遍历list)
    - [`List`和`Array`转换](#list和array转换)
    - [编写`equals`方法](#编写equals方法)
    - [`List`方法](#list方法)
    - [`ListIterator`方法](#listiterator方法)
    - [`LinkedList`方法](#linkedlist方法)
  - [](#)

<!-- /TOC -->
# 集合
## 综述
`Java`标准库自带的`java.util`包提供了集合类：`Collection`，它是除`Map`外所有其他集合类的根接口。`Java`的`java.util`包主要提供了`List`,`Set`,`Map`三种类型的集合。

`Java`集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是`List`，具体的实现类有`ArrayList`，`LinkedList`等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素。

最后，`Java`访问集合总是通过统一的方式——迭代器（`Iterator`）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。

由于`Java`的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：
- `Hashtable`：一种线程安全的`Map`实现；
- `Vector`：一种线程安全的`List`实现；
- `Stack`：基于`Vector`实现的LIFO的栈。

还有一小部分接口是遗留接口，也不应该继续使用：
- `Enumeration<E>`：已被`Iterator<E>`取代。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200612124914.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200612124931.png)
### 方法
`Collection`接口声明了很多有用的方法，所有的实现类都必须提供这些方法：
- `int size()`:返回当前存储在集合中的元素个数
- `boolean isEmpty()`:如果集合中没有元素，返回`true`
- `Iterator iterator()`：返回一个`Iterator`对象，用于遍历集合里的元素。
- `boolean contains(Object obj)`:如果集合中包含了一个与`obj`相等的对象，返回`true`
- `boollean containsAll(Collection<?> other)`:如果这个集合包含了`other`集合中的所有元素，返回`true`
- `boolean add(E element)`：将一个元素添加到集合中，如果由于这个调用改变了集合，返回`true`
- `boolean addAll(Collection<? extends E> other)`:将`other`集合中的所有元素添加到这个集合，如果由于这个调用改变了集合，返回`true`
- `boolean remove(Object obj)`：从这个集合中删除等于`obj`的对象，如果有匹配的对象被删除，返回`true`,当集合中包括了一个或多个元素`obj`时，只删除第一个符合条件的元素。
- `boolean removeAll(Collection<?> other)`:从这个集合中删除`other`集合中存在的所有元素，如果由于这个调用改变了集合，返回`true`
- `default boolean removeIf(Predict<? super E> filter)`:从这个集合删除`filter`返回`true`的所有元素。如果由于这个调用改变了集合，则返回`true`。
- `void clear()`:从这个集合中删除所有元素。
- `boolean retainAll(Collection<?> other)`：从这个集合中删除所有与`other`集合中元素不同的元素。即取交集。如果由于这个调用改变了集合，返回`true`。
- `Object[] toArray()`：返回这个集合中的对象的数组。

当使用`System.out`的`println()`方法来输出集合对象时，将输出`[ele1,ele2...]`的形式，因为所有的`Collection`实现类都重写了`toString`方法。可以一次性输出集合中的所有元素。

`Java11`为`Collection`新增了一个`toArray(IntFunction)`方法，当`Collection`使用泛型时，`toArray(IntFunction)`可以返回特定类型的数组，而传统的`toArray()`方法，返回值总是`Object[]`。

```java
//该Collection使用了泛型，指定它的集合元素都是String
var strColl=List.of("Java","Kotlin","Swift","Python");
//toArray()方法参数是一个Lambda表达式，代表IntFunction对象
//此时toArray()方法的返回值类型是String[]，而不是Object[]
String[] sa=strColl.toArray(String[]::new);
```
末行示范了`toArray(IntFunction)`方法的特点，由于编译器推断`strColl`的类型为`List<String>`(带泛型)，因此`toArray(IntFunction)`方法参数通常就是它要返回的数组类型后面加双冒号和`new`(构造器引用)。
### 迭代器
`Java`迭代器位于两个元素之间，当调用`next`时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。

`Iterator`方法:
- `boolean hasNext()`:如果存在另一个可访问的元素，返回`true`
- `E next()`：返回将要访问的下一个对象，如果已经到了集合的末尾，将抛出一个`NoSuchElementException`。
- `void remove`:删除上次访问的对象，这个方法必须紧跟在访问一个元素后执行，如果上次访问之后集合发生了变化，这个方法将抛出一个`IllegalStateException`
- `default void forEachRemaining(Consumer<? super E> action)`:访问元素，并传递到指定动作，直到再没有更多元素，或者这个动作抛出一个异常。

删除第一个元素:
```java
Iterator<String> it=c.iterator();
it.next();//skip over the first element
it.remove();//now remove it
```
`next`方法和`remove`方法调用之间存在依赖性，如果调用`remove`之前没有调用`next`，将是不合法的，如果这样做，将会抛出一个`IllegalStatException`异常。
如果想删除两个相邻的元素，不能直接这样调用：
```java
it.remove();
it.remove();
```
实际上，必须要先调用`next`越过将要删除的元素：
```java
it.remove();
it.next();
it.remove();
```
当使用`Iterator`对集合元素进行迭代时，`Iterator`并不是把集合元素本身传递给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。

当使用`Iterator`迭代访问`Collection`集合元素时，`Collection`集合里的元素不能被改变，只有通过`Iterator`的`remove`方法删除上一次`next()`方法返回的集合元素才可以。即位于`Iterator`迭代块内修改`Collection`集合的方式会引发异常。

`Iterator`采用的是快速失败(fail-fast)机制，一旦在迭代中检测到该集合已经被修改，程序立即引发`ConcurrentModificationException`异常，而不是显示修改后的结果，这样可以避免共享资源引发的潜在问题。
## `List`
`List`作为`Collection`的子接口，可以使用`Collection`接口里的全部方法。

在`Java`程序设计语言中，所有链表实际都是双向链表。

定义一个整型数组列表，尖括号中的类型参数不允许是基本类型，也就是说，不允许写成`ArrayList<int>`。需要用到`Integer`包装类，可以声明一个`Integer`对象的数组列表:
```java
var list=new ArrayList<Integer>();
```

由于每个值分别包装在对象中，所以`ArrayList<Integer>`的效率远远低于`int[]`数组。因此，只有当程序员操作方便性比执行效率更重要的时候，才会考虑对较小的集合使用这种构造。

考察`List<E>`接口，可以看到几个主要的接口方法：
- 在末尾添加一个元素：`void add(E e)`
- 在指定索引添加一个元素：`void add(int index, E e)`
- 删除指定索引的元素：`int remove(int index)`
- 删除某个元素：`int remove(Object e)`
- 获取指定索引的元素：`E get(int index)`
- 获取链表大小（包含元素的个数）：`int size()`

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200611213403.png)

`List`还允许添加`null`：
```java
import java.util.ArrayList;
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("apple"); // size=1
        list.add(null); // size=2
        list.add("pear"); // size=3
        String second = list.get(1); // null
        System.out.println(second);
    }
}
```
### 创建`List`
除了使用`ArrayList`和`LinkedList`，我们还可以通过`List`接口提供的`of()`方法，根据给定元素快速创建`List`：
```java
List<Integer> list = List.of(1, 2, 5);
```
但是`List.of()`方法不接受`null`值，如果传入`null`，会抛出`NullPointerException`异常。

### 遍历`List`
和数组类型，我们要遍历一个`List`，完全可以用`for`循环根据索引配合`get(int)`方法遍历：
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("apple", "pear", "banana");
        for (int i=0; i<list.size(); i++) {
            String s = list.get(i);
            System.out.println(s);
        }
    }
}
```
但这种方式并不推荐:
1. 代码复杂
2. `get(int)`方法只有`ArrayList`的实现是高效的，换成`LinkedList`后，索引越大，访问速度越慢。

要始终坚持使用迭代器`Iterator`来访问`List`。通过`Iterator`遍历`List`永远是最高效的方式。`Iterator`本身也是一个对象，但它是由List的实例调用`iterator()`方法的时候创建的。`Iterator`对象知道如何遍历一个`List`，并且不同的`List`类型，返回的`Iterator`对象实现也是不同的，但总是具有最高的访问效率。

`Iterator`对象有两个方法：`boolean hasNext()`判断是否有下一个元素，`E next()`返回下一个元素。因此，使用`Iterator`遍历`List`代码如下：
```java
import java.util.Iterator;
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("apple", "pear", "banana");
        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
            String s = it.next();
            System.out.println(s);
        }
    }
}
```
`Java`的`for each`循环本身就可以帮我们使用`Iterator`遍历:
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("apple", "pear", "banana");
        for (String s : list) {
            System.out.println(s);
        }
    }
}
```
实际上，只要实现了`Iterable`接口的集合类都可以直接用`for each`循环来遍历，`Java`编译器本身并不知道如何遍历集合对象，但它会自动把`for each`循环变成`Iterator`的调用，原因就在于`Iterable`接口定义了一个`Iterator<E> iterator()`方法，强迫集合类必须返回一个`Iterator`实例。

### `List`和`Array`转换
给`toArray(T[])`传入一个类型相同的`Array`，`List`内部自动把元素复制到传入的`Array`中：
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<Integer> list = List.of(12, 34, 56);
        Integer[] array = list.toArray(new Integer[3]);
        for (Integer n : array) {
            System.out.println(n);
        }
    }
}
```
注意到这个`toArray(T[])`方法的泛型参数`<T>`并不是`List`接口定义的泛型参数`<E>`，所以，我们实际上可以传入其他类型的数组，例如我们传入`Number`类型的数组，返回的仍然是`Number`类型：
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<Integer> list = List.of(12, 34, 56);
        Number[] array = list.toArray(new Number[3]);
        for (Number n : array) {
            System.out.println(n);
        }
    }
}
```
但是，如果传入类型不匹配的数组，例如，`String[]`类型的数组，由于`List`的元素是`Integer`，所以无法放入`String`数组，这个方法会抛出`ArrayStoreException`。

如果传入的数组大小和`List`实际的元素个数不一致:

如果传入的数组不够大，那么`List`内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比`List`元素还要多，那么填充完元素后，剩下的数组元素一律填充`null`。

实际上，最常用的是传入一个“恰好”大小的数组：
```java
Integer[] array = list.toArray(new Integer[list.size()]);
```

最后一种更简洁的写法是通过`List`接口定义的`T[] toArray(IntFunction<T[]> generator)`方法：
```java
Integer[] array = list.toArray(Integer[]::new);
```

把`Array`变为`List`通过`List.of(T...)`方法最简单：
```java
Integer[] array = { 1, 2, 3 };
List<Integer> list = List.of(array);
```

要注意的是，返回的`List`不一定就是`ArrayList`或者`LinkedList`，因为`List`只是一个接口，如果我们调用`List.of()`，它返回的是一个只读`List`：
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<Integer> list = List.of(12, 34, 56);
        list.add(999); // UnsupportedOperationException
    }
}
```
对只读`List`调用`add()`、`remove()`方法会抛出`UnsupportedOperationException`。

### 编写`equals`方法
`List`还提供了`boolean contains(Object o)`方法来判断`List`是否包含某个指定元素。此外，`int indexOf(Object o)`方法可以返回某个元素的索引，如果元素不存在，就返回-1。
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("A", "B", "C");
        System.out.println(list.contains("C")); // true
        System.out.println(list.contains("X")); // false
        System.out.println(list.indexOf("C")); // 2
        System.out.println(list.indexOf("X")); // -1
    }
}
```
这里我们注意一个问题，我们往`List`中添加的`"C"`和调用`contains("C")`传入的`"C"`是不是同一个实例？

如果这两个`"C"`不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：
```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("A", "B", "C");
        System.out.println(list.contains(new String("C"))); // true
        System.out.println(list.indexOf(new String("C"))); // 2
    }
}
```
因为我们传入的是`new String("C")`，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？

因为`List`内部并不是通过`==`判断两个元素是否相等，而是使用`equals()`方法判断两个元素是否相等，例如`contains()`方法可以实现如下：
```java
public class ArrayList {
    Object[] elementData;
    public boolean contains(Object o) {
        for (int i = 0; i < size; i++) {
            if (o.equals(elementData[i])) {
                return true;
            }
        }
        return false;
    }
}
```
因此，要正确使用`List`的`contains()`、`indexOf()`这些方法，放入的实例必须正确覆写`equals()`方法，否则，放进去的实例，查找不到。我们之所以能正常放入`String`、`Integer`这些对象，是因为`Java`标准库定义的这些类已经正确实现了`equals()`方法。

```java
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<Person> list = List.of(
            new Person("Xiao Ming"),
            new Person("Xiao Hong"),
            new Person("Bob")
        );
        System.out.println(list.contains(new Person("Bob"))); // false
    }
}

class Person {
    String name;
    public Person(String name) {
        this.name = name;
    }
}
```
不出意外，虽然放入了`new Person("Bob")`，但是用另一个`new Person("Bob")`查询不到，原因就是`Person`类没有覆写`equals()`方法。

`equals()`方法要求我们必须满足以下条件：
- 自反性（Reflexive）：对于非`null`的x来说，`x.equals(x)`必须返回`true`；
- 对称性（Symmetric）：对于非`null`的`x`和`y`来说，如果`x.equals(y)`为`true`，则`y.equals(x)`也必须为`true`；
- 传递性（Transitive）：对于非`null`的`x`、`y`和`z`来说，如果`x.equals(y)`为`true，y.equals(z)`也为`true`，那么`x.equals(z)`也必须为`true`；
- 一致性（Consistent）：对于非`null`的`x`和`y`来说，只要`x`和`y`状态不变，则`x.equals(y)`总是一致地返回`true`或者`false`；
- 对`null`的比较：即`x.equals(null)`永远返回`false`。

```java
public boolean equals(Object o) {
    if (o instanceof Person) {
        Person p = (Person) o;
        boolean nameEquals = false;
        if (this.name == null && p.name == null) {
            nameEquals = true;
        }
        if (this.name != null) {
            nameEquals = this.name.equals(p.name);
        }
        return nameEquals && this.age == p.age;
    }
    return false;
}
```
要简化引用类型的比较，我们使用`Objects.equals()`静态方法：
```java
public boolean equals(Object o) {
    if (o instanceof Person) {
        Person p = (Person) o;
        return Objects.equals(this.name, p.name) && this.age == p.age;
    }
    return false;
}
```

`equals()`方法的正确编写方法：
- 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；
- 用`instanceof`判断传入的待比较的`Object`是不是当前类型，如果是，继续比较，否则，返回`false`；
- 对引用类型用`Objects.equals()`比较，对基本类型直接用`==`比较。

使用`Objects.equals()`比较两个引用类型是否相等的目的是省去了判断`null`的麻烦。两个引用类型都是`null`时它们也是相等的。

如果不调用`List`的`contains()`、`indexOf()`这些方法，那么放入的元素就不需要实现`equals()`方法。

### `List`方法
- `ListIterator<E> listIterator()`:返回一个列表迭代器，用来访问列表中的元素。
- `ListIterator<E> listIterator(int index)`:返回一个列表迭代器，用来访问列表中的元素，第一次调用这个迭代器的`next`会返回给定索引的元素。
- `void add(E element)`:在末尾添加一个元素。
- `void add(int i,E element)`:在给定位置添加一个元素。
- `void addAll(int i,Collection<? extends E> elements)`:将一个集合中所有元素添加到给定位置。
- `E remove(int i)`:删除并返回给定位置的元素。
- `E get(int i)`:获取给定位置的元素。
- `E set(int i,E element)`:用一个新元素替换给定位置的元素，并返回原来的那个元素。
- `int indexOf(Object element)`:返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素返回-1。
- `int lastIndexOf(Object element)`:返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素返回-1。
- `List subList(int fromIndex,int toIndex)`:返回从索引`fromIndex`到索引`toIndex`(不包含)处所有集合元素组成的子集合。
- `void sort(Comparator c)`:根据`Comparator`参数对`List`集合的元素排序。

`List`判断两个对象相等是通过`equals()`方法，`remove(Object obj)`,`indexOf(Object obj)`都可以传入`new Object()`来进行操作。

`sort()`方法需要一个`Comparator`对象来控制元素排序，程序可以使用`Lambda`表达式作为参数：
```java
var books=new ArrayList<String>();
books.add("abc");
books.add("asdaqwdq");
books.add("a");
books.sort((o1,o2)->o1.length()-o2.length());//[a, abc, asdaqwdq]
```
### `ListIterator`方法
- `void add(E element)`:在当前位置前添加一个元素。
- `void set(E newElement)`:用新元素替换`next`或`previous`访问的上一个元素，如果在上一个`next`或`previous`调用之后列表的结构被修改了，将抛出一个`IllegalStateException`异常。
- `boolean hasPrevious()`:当反向迭代列表时，如果还有可以访问的元素，返回`true`
- `E previous`():返回前一个对象，如果已经到达了列表的头部，就抛出一个`NoSuchElementException`异常。
- `int nextIndex()`:返回下一次调用`next`方法时将要返回的元素的索引。
- `int previousIndex()`:返回下一次调用`previous`方法时将返回的元素的索引。

使用`ListIterator`反向迭代时，开始也需要采用正向迭代：
```java
public static void main(String[] args){
    String[] books={"a","b","c"};
    var bookList=new ArrayList<String>();
    for(var i=0;i<books.length;++i){
        bookList.add(books[i]);
    }
    var lit=bookList.listIterator();
    while(lit.hasNext()){
        System.out.println(lit.next());
        lit.add("---分隔符---");
    }
    System.out.println("开始反向迭代");
    while(lit.hasPrevious()){
        System.out.println(lit.previous());
    }
}
```
### `LinkedList`方法
- `LinkedList()`：构造一个空列表。
- `LinkedList(Collection<? extends E> elements)`:构造一个链表，并将集合中所有的元素添加到这个链表中。
- `void addFirst(E element)`
- `void addLast(E element)`:将某个元素添加到头部或尾部。
- `E getFirst()`
- `E getLast()`:返回头部或尾部的元素。
- `E removeFirst()`
- `E removeLast()`:删除并返回头部或尾部的元素。
## 






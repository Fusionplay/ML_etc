<!-- TOC -->

- [`Java`快速入门](#java快速入门)
  - [`Java`简介](#java简介)
    - [名词解释](#名词解释)
  - [第一个Java程序](#第一个java程序)
  - [Java程序基础](#java程序基础)
    - [Java程序基本结构](#java程序基本结构)
    - [变量和数据类型](#变量和数据类型)
      - [变量](#变量)
      - [基本数据类型](#基本数据类型)
        - [整型](#整型)
          - [溢出](#溢出)
          - [自增/自减](#自增自减)
          - [移位运算](#移位运算)
          - [位运算](#位运算)
          - [运算优先级](#运算优先级)
          - [类型自动提升与强制转型](#类型自动提升与强制转型)
        - [浮点型](#浮点型)
          - [类型提升](#类型提升)
          - [溢出](#溢出-1)
          - [强制转型](#强制转型)
        - [布尔类型](#布尔类型)
          - [短路运算](#短路运算)
          - [三元运算符](#三元运算符)
        - [字符类型](#字符类型)
          - [字符串类型](#字符串类型)
          - [字符串连接](#字符串连接)
          - [多行字符串](#多行字符串)
          - [不可变特性](#不可变特性)
          - [空值`null`](#空值null)
        - [引用类型](#引用类型)
        - [数组类型](#数组类型)
          - [字符串数组](#字符串数组)
        - [常量](#常量)
        - [`var`关键字](#var关键字)
        - [变量的作用范围](#变量的作用范围)
  - [流程控制](#流程控制)
    - [输入和输出](#输入和输出)
      - [输出](#输出)
        - [格式化输出](#格式化输出)
      - [输入](#输入)
    - [`if`判断](#if判断)
      - [判断引用类型相等](#判断引用类型相等)
    - [`switch`多重选择](#switch多重选择)
      - [`switch`表达式](#switch表达式)
      - [`yield`](#yield)
    - [`while`循环](#while循环)
    - [`for`循环](#for循环)
      - [`for each`循环](#for-each循环)
  - [数组操作](#数组操作)
    - [遍历数组](#遍历数组)
      - [打印数组内容](#打印数组内容)
    - [数组排序](#数组排序)
    - [多维数组](#多维数组)
      - [二维数组](#二维数组)
      - [三维数组](#三维数组)
    - [命令行参数](#命令行参数)

<!-- /TOC -->
# `Java`快速入门
## `Java`简介
Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。

### 名词解释
- JDK：Java Development Kit
- JRE：Java Runtime Environment

JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。

二者关系如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200425222226.png)

- JSR规范：Java Specification Request
- JCP组织：Java Community Process

为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。

所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。

一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：

- RI：Reference Implementation
- TCK：Technology Compatibility Kit

比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。

## 第一个Java程序
```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```
在一个Java程序中，你总能找到一个类似：
```java
public class Hello {
    ...
}
```
的定义，这个定义被称为`class`（类），这里的类名是`Hello`，大小写敏感，`class`用来定义一个类，`public`表示这个类是公开的，`public`、`class`都是Java的关键字，必须小写，`Hello`是类的名字，按照习惯，首字母H要大写。而花括号`{}`中间则是类的定义。

注意到类的定义中，我们定义了一个名为`main`的方法：
```java
public static void main(String[] args) {
        ...
    }
```
方法是可执行的代码块，一个方法除了方法名`main`，还有用`()`括起来的方法参数，这里的`main`方法有一个参数，参数类型是`String[]`，参数名是`args`，`public`、`static`用来修饰方法，这里表示它是一个公开的静态方法，`void`是方法的返回类型，而花括号`{}`中间的就是方法的代码。

方法的代码每一行用`;`结束，这里只有一行代码，就是：
```java
System.out.println("Hello, world!");
```
Java规定，某个类定义的`public static void main(String[] args)`是Java程序的固定入口方法，因此，Java程序总是从`main`方法开始执行。

当我们把代码保存为文件时，文件名必须是`Hello.java`，而且文件名也要注意大小写，因为要和我们定义的类名`Hello`完全保持一致。

## Java程序基础
### Java程序基本结构
因为Java是面向对象的语言，一个程序的基本单位就是`class`，`class`是关键字，这里定义的`class`名字就是Hello：
```java
public class Hello { // 类名是Hello
    // ...
} // class定义结束
```
类名要求：
1. 类名必须以英文字母开头，后接字母，数字和下划线的组合
2. 习惯以大写字母开头

注意到`public`是访问修饰符，表示该`class`是公开的。不写`public`，也能正确编译，但是这个类将无法从命令行执行。

在`class`内部，可以定义若干方法（method）：
```java
public class Hello {
    public static void main(String[] args) { // 方法名是main
        // 方法代码...
    } // 方法定义结束
}
```
方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。

这里的方法名是`main`，返回值是`void`，表示没有任何返回值。

我们注意到`public`除了可以修饰`class`外，也可以修饰方法。而关键字`static`是另一个修饰符，它表示静态方法，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为`main`，括号内的参数必须是`String`数组。

方法名也有命名规则，命名和`class`一样，但是首字母小写。

在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束：
```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!"); // 语句
    }
}
```
在Java程序中，注释是一种给人阅读的文本，不是程序的一部分，所以编译器会自动忽略注释。

Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束：
```java
// 这是注释...
```
而多行注释以`/*`星号开头，以`*/`结束，可以有多行：
```java
/*
这是注释
blablabla...
这也是注释
*/
```
还有一种特殊的多行注释，以`/**`开头，以`*/`结束，如果有多行，每行通常以星号开头：
```java
/**
 * 可以用来自动创建文档的注释
 * 
 * @auther liaoxuefeng
 */
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```
这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。

### 变量和数据类型
#### 变量
在Java中，变量分为两种：基本类型的变量和引用类型的变量。

在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如：
```java
int x = 1;
```
上述语句定义了一个整型`int`类型的变量，名称为`x`，初始值为`1`。不写初始值，就相当于给它指定了默认值。默认值总是`0`。

变量的一个重要特点是可以重新赋值。第一次定义变量x的时候，需要指定变量类型。而第二次重新赋值的时候，变量已经存在了，不能再重复定义，因此不能指定变量类型。

变量不但可以重新赋值，还可以赋值给其他变量。

#### 基本数据类型
基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：
- 整数类型：byte(1Byte)，short(2Byte)，int(4Byte)，long(8Byte)

- 浮点数类型：float(4Byte)，double(8Byte)

- 字符类型：char(2Byte)

- 布尔类型：boolean

##### 整型
对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：
- byte：-128 ~ 127
- short: -32768 ~ 32767
- int: -2147483648 ~ 2147483647
- long: -9223372036854775808 ~ 9223372036854775807
整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分，求余运算使用`%`。

特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。

###### 溢出
```java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
```
要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果。解决上面的问题，可以把`int`换成`long`类型，由于`long`可表示的整型范围更大，所以结果就不会溢出：
```java
long x = 2147483640;
long y = 15;
long sum = x + y;
System.out.println(sum); // 2147483655
```
还有一种简写的运算符，即`+=`，`-=`，`*=`，`/=`，它们的使用方法如下：
```java
n += 100; // 3409, 相当于 n = n + 100;
n -= 100; // 3309, 相当于 n = n - 100;
```
###### 自增/自减
Java还提供了`++`运算和`--`运算，它们可以对一个整数进行加1和减1的操作,注意`++`写在前面和后面计算结果是不同的，`++n`表示先加1再引用n，`n++`表示先引用n再加1。不建议把`++`运算混入到常规运算中，容易自己把自己搞懵了。
###### 移位运算
可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：
```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
```
左移29位时，由于最高位变成1，因此结果变成了负数。

类似的，对整数28进行右移，结果如下：
```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```
如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：
```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```
还有一种不带符号的右移运算，使用`>>>`，它的特点是符号位跟着动，因此，对一个负数进行`>>>`右移，它会变成正数，原因是最高位的1变成了0：
```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```
对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移。仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。
###### 位运算
位运算是按位进行与、或、非和异或的运算。

与运算的规则是，必须两个数同时为1，结果才为1：
```java
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```
或运算的规则是，只要任意一个为1，结果就为1：
```java
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```
非运算的规则是，0和1互换：
```java
n = ~0; // 1
n = ~1; // 0
```
异或运算的规则是，如果两个数不同，结果为1，否则为0：
```java
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```
对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：
```java
public class Main {
    public static void main(String[] args) {
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & n); // 167776512
    }
}
```
上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。

###### 运算优先级
在Java的计算表达式中，运算优先级从高到低依次是：

- `()`
- `! ~ ++ --`
- `* / %`
- `+ -`
- `<< >> >>>`
- `&`
- `|`
- `+= -= *= /=`

###### 类型自动提升与强制转型
在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，`short`和`int`计算，结果总是`int`，原因是`short`首先自动被转型为`int`：
```java
public class Main {
    public static void main(String[] args) {
        short s = 1234;
        int i = 123456;
        int x = s + i; // s自动转型为int
        short y = s + i; // 编译错误!
    }
}
```
也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用`(类型)`，例如，将`int`强制转型为`short`：
```java
int i = 12345;
short s = (short) i; // 12345
```
要注意，超出范围的强制转型会得到错误的结果，原因是转型时，`int`的两个高位字节直接被扔掉，仅保留了低位的两个字节：
```java
public class Main {
    public static void main(String[] args) {
        int i1 = 1234567;
        short s1 = (short) i1; // -10617
        System.out.println(s1);
        int i2 = 12345678;
        short s2 = (short) i2; // 24910
        System.out.println(s2);
    }
}
```
因此，强制转型的结果很可能是错的。
##### 浮点型
```java
float f1 = 3.14f;
float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38
double d = 1.79e308;
double d2 = -1.79e308;
double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324
```
对于`float`类型，需要加上`f`后缀。浮点数可表示的范围非常大，`float`类型可最大表示3.4e38f，而double类型可最大表示1.79e308。

浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。

如浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用`float`还是`double`，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。

因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：
```java
public class Main {
    public static void main(String[] args) {
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);//0.1
        System.out.println(y);//0.09999999999999998
    }
}
```

由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：
```java
// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r < 0.00001) {
    // 可以认为相等
} else {
    // 不相等
}
```
浮点数在内存的表示方法和整数比更加复杂。
###### 类型提升
如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型。

需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：
```java
double d = 1.2 + 24 / 5; // 5.2
```
计算结果为5.2，原因是编译器计算24 / 5这个子表达式时，按两个整数进行运算，结果仍为整数4。

###### 溢出
整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：

- `NaN`表示Not a Number
- `Infinity`表示无穷大
- `-Infinity`表示负无穷大

例如：
```java
double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity
```
###### 强制转型
可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：
```java
int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
```
如果要进行四舍五入，可以对浮点数加上0.5再强制转型：
```java
public class Main {
    public static void main(String[] args) {
        double d = 2.6;
        int n = (int) (d + 0.5);
        System.out.println(n);
    }
}
```

##### 布尔类型
布尔类型`boolean`只有`true`和`false`两个值，布尔类型总是关系运算的计算结果。

Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把`boolean`表示为4字节整数。

布尔运算是一种关系运算，包括以下几类：

- 比较运算符：`>`，`>=`，`<`，`<=`，`==`，`!=`
- 与运算 `&&`
- 或运算 `||`
- 非运算 `!`

关系运算符的优先级从高到低依次是：

- `!`
- `>`，`>=`，`<`，`<=`
- `==`，`!=`
- `&&`
- `||`

###### 短路运算
布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。

因为`false && x`的结果总是`false`，无论x是`true`还是`false`，因此，与运算在确定第一个值为`false`后，不再继续计算，而是直接返回`false`

考察以下代码：
```java
public class Main {
    public static void main(String[] args) {
        boolean b = 5 < 3;
        boolean result = b && (5 / 0 > 0);
        System.out.println(result);
    }
}
```
如果没有短路运算，`&&`后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果`false`。

如果变量b的值为`true`，则表达式变为`true && (5 / 0 > 0)`。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试。

类似的，对于`||`运算，只要能确定第一个值为`true`，后续计算也不再进行，而是直接返回`true`：
```java
boolean result = true || (5 / 0 > 0); // true
```
###### 三元运算符
Java还提供一个三元运算符`b ? x : y`，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例：
```java
public class Main {
    public static void main(String[] args) {
        int n = -100;
        int x = n >= 0 ? n : -n;
        System.out.println(x);
    }
}
```
注意到三元运算`b ? x : y`会首先计算`b`，如果`b`为`true`，则只计算`x`，否则，只计算`y`。此外，`x`和`y`的类型必须相同，因为返回值不是`boolean`，而是`x`和`y`之一。
##### 字符类型
字符类型`char`表示一个字符。Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符：
```java
public class Main {
    public static void main(String[] args) {
        char a = 'A';
        char zh = '中';
        System.out.println(a);
        System.out.println(zh);
    }
}
```
注意`char`类型使用单引号`'`，且仅有一个字符，要和双引号`"`的字符串类型区分开。

因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个`char`类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可：
```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```
还可以直接用转义字符`\u+Unicode编码`来表示一个字符：
```java
// 注意是十六进制:
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```
###### 字符串类型
和`char`类型不同，字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串。一个字符串可以存储0个到任意个字符：
```java
String s = ""; // 空字符串，包含0个字符
String s1 = "A"; // 包含一个字符
String s2 = "ABC"; // 包含3个字符
String s3 = "中文 ABC"; // 包含6个字符，其中有一个空格
```
因为字符串使用双引号`"..."`表示开始和结束，那如果字符串本身恰好包含一个`"`字符怎么表示？例如，`"abc"xyz"`，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符`\`：
```java
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z
```
因为`\`是转义字符，所以，两个`\\`表示一个`\`字符：
```java
String s = "abc\\xyz"; // 包含7个字符: a, b, c, \, x, y, z
```
常见的转义字符包括：

- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示`Tab`
- `\u####` 表示一个Unicode编码的字符

例如：
```java
String s = "ABC\n\u4e2d\u6587"; // 包含6个字符: A, B, C, 换行符, 中, 文
```
###### 字符串连接
Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。

如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。
```java
public class Main {
    public static void main(String[] args) {
        int age = 25;
        String s = "age is " + age;
        System.out.println(s);
    }
}
```
###### 多行字符串
如果我们要表示多行字符串，使用+号连接会非常不方便：
```java
String s = "first line \n"
         + "second line \n"
         + "end";
```
从Java 13开始，字符串可以用`"""..."""`表示多行字符串（Text Blocks）了。举个例子：
```java
public class Main {
    public static void main(String[] args) {
        String s = """
                   SELECT * FROM
                     users
                   WHERE id > 100
                   ORDER BY name DESC
                   """;
        System.out.println(s);
    }
}
```
上述多行字符串实际上是5行，在最后一个DESC后面还有一个`\n`。如果我们不想在字符串末尾加一个`\n`，就需要这么写：
```java
String s = """ 
           SELECT * FROM
             users
           WHERE id > 100
           ORDER BY name DESC""";
```
还需要注意到，多行字符串前面共同的空格会被去掉，即：
```java
String s = """
...........SELECT * FROM
...........  users
...........WHERE id > 100
...........ORDER BY name DESC
...........""";
```
用`.`标注的空格都会被去掉。

如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：
```java
String s = """
.........  SELECT * FROM
.........    users
.........WHERE id > 100
.........  ORDER BY name DESC
.........  """;
```
即总是以最短的行首空格为基准。

最后，由于多行字符串是作为预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：
```java
javac --source 14 --enable-preview Main.java
```
###### 不可变特性
Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：
```java
public class Main {
    public static void main(String[] args) {
        String s = "hello";
        System.out.println(s); // 显示 hello
        s = "world";
        System.out.println(s); // 显示 world
    }
}
```
观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。

执行`String s = "hello";`时，JVM虚拟机先创建字符串`"hello"`，然后，把字符串变量s指向它。

紧接着，执行`s = "world";`时，JVM虚拟机先创建字符串`"world"`，然后，把字符串变量s指向它。

###### 空值`null`
引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。例如：
```java
String s1 = null; // s1是null
String s2; // 没有赋初值值，s2也是null
String s3 = s1; // s3也是null
String s4 = ""; // s4指向空字符串，不是null
```
注意要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`。
##### 引用类型
除了基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是`String`字符串：
```java
String s = "hello";
```
引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。
##### 数组类型
定义一个数组类型的变量，使用数组类型`“类型[]”`，例如，`int[]`。和单个基本类型变量不同，数组变量初始化必须使用`new int[5]`表示创建一个可容纳5个`int`元素的数组。

Java的数组有几个特点：

- 数组所有元素初始化为默认值，整型都是`0`，浮点型是`0.0`，布尔型是`false`；
- 数组一旦创建后，大小就不可改变。
- 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。

可以修改数组中的某一个元素，使用赋值语句，例如，`ns[1] = 79;`。

可以用`数组变量.length`获取数组大小。

也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：
```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 编译器自动推算数组大小为5
    }
}
```
还可以进一步简写为：
```java
int[] ns = { 68, 79, 91, 85, 62 };
```
注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：
```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```
数组大小变了吗？看上去好像是变了，但其实根本没变。

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：
![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428173806.png)

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：
![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428173849.png)

但是，原有的5个元素的数组并没有改变，只是无法通过变量`ns`引用到它们而已。

###### 字符串数组
字符串是引用类型，因此我们先定义一个字符串数组：
```java
String[] names = {
    "ABC", "XYZ", "zoo"
};
```
对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428174200.png)

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：
![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428174225.png)

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

##### 常量
定义变量的时候，如果加上`final`修饰符，这个变量就变成了常量：
```java
final double PI = 3.14; // PI是一个常量
double r = 5.0;
double area = PI * r * r;
PI = 300; // compile error!
```
常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。

根据习惯，常量名通常全部大写。

##### `var`关键字
有些时候，类型的名字太长，写起来比较麻烦。例如：
```java
StringBuilder sb = new StringBuilder();
```
这个时候，如果想省略变量类型，可以使用`var`关键字：
```java
var sb = new StringBuilder();
```
编译器会根据赋值语句自动推断出变量`sb`的类型是`StringBuilder`。对编译器来说，语句：
```java
var sb = new StringBuilder();
```
实际上会自动变成:
```java
StringBuilder sb = new StringBuilder();
```
因此，使用`var`定义变量，仅仅是少写了变量类型而已。

##### 变量的作用范围
在Java中，多行语句用`{ }`括起来。很多控制语句，例如条件判断和循环，都以`{ }`作为它们自身的范围，例如：
```java
if (...) { // if开始
    ...
    while (...) { while 开始
        ...
        if (...) { // if开始
            ...
        } // if结束
        ...
    } // while结束
    ...
} // if结束
```
只要正确地嵌套这些`{ }`，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子：
```java
{
    ...
    int i = 0; // 变量i从这里开始定义
    ...
    {
        ...
        int x = 1; // 变量x从这里开始定义
        ...
        {
            ...
            String s = "hello"; // 变量s从这里开始定义
            ...
        } // 变量s作用域到此结束
        ...
        // 注意，这是一个新的变量s，它和上面的变量同名，
        // 但是因为作用域不同，它们是两个不同的变量:
        String s = "hi";
        ...
    } // 变量x和s作用域到此结束
    ...
} // 变量i作用域到此结束
```
定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。
## 流程控制
### 输入和输出
#### 输出
`println`是`print line`的缩写，表示输出并换行。因此，如果输出后不想换行，可以用`print()`。

##### 格式化输出
格式化输出使用`System.out.printf()`，通过使用占位符`%?`，`printf()`可以把后面的参数格式化成指定格式：
```java
public class Main {
    public static void main(String[] args) {
        double d = 3.1415926;
        System.out.printf("%.2f\n", d); // 显示两位小数3.14
        System.out.printf("%.4f\n", d); // 显示4位小数3.1416
    }
}
```
Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：
- `%d`:格式化输出整数
- `%x`:格式化输出十六进制整数
- `%f`:格式化输出浮点数
- `%e`:格式化输出科学计数法表示的浮点数
- `%s`:格式化字符串

注意，由于`%`表示占位符，因此，连续两个`%%`表示一个`%`字符本身。

占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：
```java
public class Main {
    public static void main(String[] args) {
        int n = 12345000;
        System.out.printf("n=%d, hex=%08x", n, n); // 注意，两个%占位符必须传入两个数
    }
}
```
#### 输入
和输出相比，Java的输入就要复杂得多。我们先看一个从控制台读取一个字符串和一个整数的例子：
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```
首先，我们通过`import`语句导入`java.util.Scanner`，`import`是导入某个类的语句，必须放到`Java`源代码的开头。

然后，创建`Scanner`对象并传入`System.in`。`System.out`代表标准输出流，而`System.in`代表标准输入流。直接使用`System.in`读取用户输入虽然是可以的，但需要更复杂的代码，而通过`Scanner`就可以简化后续的代码。

有了`Scanner`对象后，要读取用户输入的字符串，使用`scanner.nextLine()`，要读取用户输入的整数，使用`scanner.nextInt()`。`Scanner`会自动转换数据类型，因此不必手动转换。

### `if`判断
当`if`语句块只有一行语句时，可以省略花括号`{}`,在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。

#### 判断引用类型相等
在Java中，判断值类型的变量是否相等，可以使用`==`运算符。但是，判断引用类型的变量是否相等，`==`表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个`String`类型，它们的内容是相同的，但是，分别指向不同的对象，用`==`判断，结果为`false`：
```java
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "HELLO".toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1 == s2) {
            System.out.println("s1 == s2");
        } else {
            System.out.println("s1 != s2");//输出这一行
        }
    }
}
```
要判断引用类型的变量内容是否相等，必须使用`equals()`方法：
```java
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "HELLO".toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1.equals(s2)) {
            System.out.println("s1 equals s2");
        } else {
            System.out.println("s1 not equals s2");
        }
    }
}
```
注意：执行语句`s1.equals(s2)`时，如果变量`s1`为`null`，会报`NullPointerException`：
```java
public class Main {
    public static void main(String[] args) {
        String s1 = null;
        if (s1.equals("hello")) {
            System.out.println("hello");
        }
    }
}
```
要避免`NullPointerException`错误，可以利用短路运算符`&&`：
```java
public class Main {
    public static void main(String[] args) {
        String s1 = null;
        if (s1 != null && s1.equals("hello")) {
            System.out.println("hello");
        }
    }
}
```
还可以把一定不是`null`的对象`"hello"`放到前面：例如：`if ("hello".equals(s)) { ... }`。
### `switch`多重选择
`switch`语句根据`switch (表达式)`计算的结果，跳转到匹配的`case`结果，然后继续执行后续语句，直到遇到`break`结束执行。

```java
public class Main {
    public static void main(String[] args) {
        int option = 1;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
            System.out.println("Selected 2");
            break;
        case 3:
            System.out.println("Selected 3");
            break;
        }
    }
}
```
如果`option`的值没有匹配到任何`case`，例如`option = 99`，那么，`switch`语句不会执行任何语句。这时，可以给`switch`语句加一个`default`，当没有匹配到任何`case`时，执行`default`：
```java
public class Main {
    public static void main(String[] args) {
        int option = 99;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
            System.out.println("Selected 2");
            break;
        case 3:
            System.out.println("Selected 3");
            break;
        default:
            System.out.println("Not selected");
            break;
        }
    }
}
```
对于多个`==`判断的情况，使用`switch`结构更加清晰。

同时注意，上述“翻译”只有在`switch`语句中对每个`case`正确编写了`break`语句才能对应得上。

使用`switch`时，注意`case`语句并没有花括号`{}`，而且，`case`语句具有“穿透性”，漏写`break`将导致意想不到的结果：
```java
public class Main {
    public static void main(String[] args) {
        int option = 2;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
        case 2:
            System.out.println("Selected 2");
        case 3:
            System.out.println("Selected 3");
        default:
            System.out.println("Not selected");
        }
    }
}
```
当`option = 2`时，将依次输出`"Selected 2"`、`"Selected 3"`、`"Not selected"`，原因是从匹配到`case 2`开始，后续语句将全部执行，直到遇到`break`语句。因此，任何时候都不要忘记写`break`。

如果有几个`case`语句执行的是同一组语句块，可以这么写：
```java
public class Main {
    public static void main(String[] args) {
        int option = 2;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
        case 3:
            System.out.println("Selected 2, 3");
            break;
        default:
            System.out.println("Not selected");
            break;
        }
    }
}
```
使用`switch`语句时，只要保证有`break`，`case`的顺序不影响程序逻辑：
```java
switch (option) {
case 3:
    ...
    break;
case 2:
    ...
    break;
case 1:
    ...
    break;
}
```
`switch`语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如：
```java
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        switch (fruit) {
        case "apple":
            System.out.println("Selected apple");
            break;
        case "pear":
            System.out.println("Selected pear");
            break;
        case "mango":
            System.out.println("Selected mango");
            break;
        default:
            System.out.println("No fruit selected");
            break;
        }
    }
}
```
#### `switch`表达式
使用`switch`时，如果遗漏了`break`，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要`break`语句：
```java
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        switch (fruit) {
        case "apple" -> System.out.println("Selected apple");
        case "pear" -> System.out.println("Selected pear");
        case "mango" -> {
            System.out.println("Selected mango");
            System.out.println("Good choice!");
        }
        default -> System.out.println("No fruit selected");
        }
    }
}
```
注意新语法使用`->`，如果有多条语句，需要用`{}`括起来。不要写`break`语句，因为新语法只会执行匹配的语句，没有穿透效应。

很多时候，我们还可能用`switch`语句给某个变量赋值。例如：
```java
int opt;
switch (fruit) {
case "apple":
    opt = 1;
    break;
case "pear":
case "mango":
    opt = 2;
    break;
default:
    opt = 0;
    break;
}
```
使用新的`switch`语法，不但不需要`break`，还可以直接返回值。把上面的代码改写如下：
```java
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        int opt = switch (fruit) {
            case "apple" -> 1;
            case "pear", "mango" -> 2;
            default -> 0;
        }; // 注意赋值语句要以;结束
        System.out.println("opt = " + opt);
    }
}
```
#### `yield`
大多数时候，在`switch`表达式内部，我们会返回简单的值。但是，如果需要复杂的语句，我们也可以写很多语句，放到`{...}`里，然后，用`yield`返回一个值作为`switch`语句的返回值：
```java
public class Main {
    public static void main(String[] args) {
        String fruit = "orange";
        int opt = switch (fruit) {
            case "apple" -> 1;
            case "pear", "mango" -> 2;
            default -> {
                int code = fruit.hashCode();
                yield code; // switch语句返回值
            }
        };
        System.out.println("opt = " + opt);
    }
}
```
### `while`循环
如果循环条件的逻辑写得有问题，也会造成意料之外的结果：
```java
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        int n = 1;
        while (n > 0) {
            sum = sum + n;
            n ++;
        }
        System.out.println(n); // -2147483648
        System.out.println(sum);
    }
}
```
表面上看，上面的`while`循环是一个死循环，但是，Java的`int`类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了`while`循环。

### `for`循环
使用`for`循环时，计数器变量`i`要尽量定义在`for`循环中：
```java
int[] ns = { 1, 4, 9, 16, 25 };
for (int i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
// 无法访问i
int n = i; // compile error!
```
如果变量`i`定义在`for`循环外：
```java
int[] ns = { 1, 4, 9, 16, 25 };
int i;
for (i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
// 仍然可以使用i
int n = i;
```
那么，退出`for`循环后，变量`i`仍然可以被访问，这就破坏了变量应该把访问范围缩到最小的原则。
#### `for each`循环

`for`循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素：
```java
int[] ns = { 1, 4, 9, 16, 25 };
for (int i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
```
但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种`for each`循环，它可以更简单地遍历数组：

```java
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int n : ns) {
            System.out.println(n);
        }
    }
}
```
和`for`循环相比，`for each`循环的变量`n`不再是计数器，而是直接对应到数组的每个元素。`for each`循环的写法也更简洁。但是，`for each`循环无法指定遍历顺序，也无法获取数组的索引。

除了数组外，`for each`循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的`List`、`Map`等。

## 数组操作
### 遍历数组
通过`for`循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的`for`循环可以完成一个数组的遍历：
```java
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int i=0; i<ns.length; i++) {
            int n = ns[i];
            System.out.println(n);
        }
    }
}
```
为了实现`for`循环遍历，初始条件为`i=0`，因为索引总是从`0`开始，继续循环的条件为`i<ns.length`，因为当`i=ns.length`时，`i`已经超出了索引范围（索引范围是`0 ~ ns.length-1`），每次循环后，`i++`。

第二种方式是使用`for each`循环，直接迭代数组的每个元素：
```java
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int n : ns) {
            System.out.println(n);
        }
    }
}
```
注意：在`for (int n : ns)`循环中，变量`n`直接拿到`ns`数组的元素，而不是索引。

显然`for each`循环更加简洁。但是，`for each`循环无法拿到数组的索引，因此，到底用哪一种`for`循环，取决于我们的需要。

#### 打印数组内容
直接打印数组变量，得到的是数组在JVM中的引用地址：
```java
int[] ns = { 1, 1, 2, 3, 5, 8 };
System.out.println(ns); // 类似 [I@7852e922
```
这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用`for each`循环来打印它：
```java
int[] ns = { 1, 1, 2, 3, 5, 8 };
for (int n : ns) {
    System.out.print(n + ", ");
}
```
使用`for each`循环打印也很麻烦。幸好Java标准库提供了`Arrays.toString()`，可以快速打印数组内容：
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 1, 2, 3, 5, 8 };
        System.out.println(Arrays.toString(ns));
    }
}
```
### 数组排序
```java
//冒泡排序
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };
        // 排序前:
        System.out.println(Arrays.toString(ns));
        for (int i = 0; i < ns.length - 1; i++) {
            for (int j = 0; j < ns.length - i - 1; j++) {
                if (ns[j] > ns[j+1]) {
                    // 交换ns[j]和ns[j+1]:
                    int tmp = ns[j];
                    ns[j] = ns[j+1];
                    ns[j+1] = tmp;
                }
            }
        }
        // 排序后:
        System.out.println(Arrays.toString(ns));
    }
}
```
实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的`Arrays.sort()`就可以排序：
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };
        Arrays.sort(ns);
        System.out.println(Arrays.toString(ns));
    }
}
```
必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：
```java
int[] ns = { 9, 3, 6, 5 };
```
在内存中，这个整型数组表示如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428202519.png)

当我们调用`Arrays.sort(ns);`后，这个整型数组在内存中变为：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428202542.png)

即变量`ns`指向的数组内容已经被改变了。

如果对一个字符串数组进行排序，例如：
```java
String[] ns = { "banana", "apple", "pear" };
```
排序前，这个数组在内存中表示如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428202627.png)

调用`Arrays.sort(ns);`排序后，这个数组在内存中表示如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428202645.png)

原来的3个字符串在内存中均没有任何变化，但是`ns`数组的每个元素指向变化了。

### 多维数组
#### 二维数组
二维数组就是数组的数组。定义一个二维数组如下：
```java
public class Main {
    public static void main(String[] args) {
        int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
        System.out.println(ns.length); // 3
    }
}
```
因为`ns`包含3个数组，因此，`ns.length`为3。实际上`ns`在内存中的结构如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428203256.png)

如果我们定义一个普通数组`arr0`，然后把`ns[0]`赋值给它：
```java
public class Main {
    public static void main(String[] args) {
        int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
        int[] arr0 = ns[0];
        System.out.println(arr0.length); // 4
    }
}
```
实际上`arr0`就获取了`ns`数组的第`0`个元素。因为`ns`数组的每个元素也是一个数组，因此，`arr0`指向的数组就是`{ 1, 2, 3, 4 }`。在内存中，结构如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428203404.png)

访问二维数组的某个元素需要使用`array[row][col]`，例如：
```java
System.out.println(ns[1][2]); // 7
```
二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义`ns`数组：
```java
int[][] ns = {
    { 1, 2, 3, 4 },
    { 5, 6 },
    { 7, 8, 9 }
};
```
这个二维数组在内存中的结构如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428203520.png)

要打印一个二维数组，可以使用两层嵌套的`for`循环：
```java
for (int[] arr : ns) {
    for (int n : arr) {
        System.out.print(n);
        System.out.print(', ');
    }
    System.out.println();
}
```

或者使用Java标准库的`Arrays.deepToString()`：
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
        System.out.println(Arrays.deepToString(ns));
    }
}
```
#### 三维数组
三维数组就是二维数组的数组。可以这么定义一个三维数组：
```java
int[][][] ns = {
    {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    },
    {
        {10, 11},
        {12, 13}
    },
    {
        {14, 15, 16},
        {17, 18}
    }
};
```

它在内存中的结构如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200428203707.png)

如果我们要访问三维数组的某个元素，例如，`ns[2][0][1]`，只需要顺着定位找到对应的最终元素15即可。理论上，我们可以定义任意的`N`维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。

### 命令行参数
Java程序的入口是`main`方法，而`main`方法可以接受一个命令行参数，它是一个`String[]`数组。
```java
public class Main {
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
```
我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个`-version`参数，打印程序版本号：

```java
public class Main {
    public static void main(String[] args) {
        for (String arg : args) {
            if ("-version".equals(arg)) {
                System.out.println("v 1.0");
                break;
            }
        }
    }
}
```

上面这个程序必须在命令行执行，我们先编译它：
```
$ javac Main.java
```
然后，执行的时候，给它传递一个`-version`参数：
```
$ java Main -version
v 1.0
```
这样，程序就可以根据传入的命令行参数，作出不同的响应。
